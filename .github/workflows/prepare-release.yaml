name: Prepare Release
run-name: ${{ inputs.dry_run && 'Prepare Release (Dry Run)' || 'Prepare Release' }}

on:
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Dry run mode (only show what would happen, no commits/pushes/PR creation)'
        required: false
        type: boolean
        default: false

jobs:
  analyze-changes:
    runs-on: ubuntu-latest
    outputs:
      should_release: ${{ steps.analyze.outputs.should_release }}
      bump_type: ${{ steps.analyze.outputs.bump_type }}
      pr_data: ${{ steps.analyze.outputs.pr_data }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        ref: develop
        fetch-depth: 0  # Need full history for comparison

    - name: Verify on develop branch
      run: |
        CURRENT_BRANCH=$(git branch --show-current)
        if [ "$CURRENT_BRANCH" != "develop" ]; then
          echo "ERROR: This workflow must run on the develop branch"
          echo "Current branch: $CURRENT_BRANCH"
          exit 1
        fi
        echo "‚úì Running on develop branch"

    - name: Get latest release tag
      id: get_tag
      run: |
        # Fetch main branch to compare
        git fetch origin main:main

        # Get the latest tag (should be on main)
        LATEST_TAG=$(git describe --tags --abbrev=0 --match "v*" 2>/dev/null || echo "")
        if [ -z "$LATEST_TAG" ]; then
          echo "ERROR: No previous release tag found"
          exit 1
        fi
        echo "latest_tag=$LATEST_TAG" >> $GITHUB_OUTPUT
        echo "Found latest release tag: $LATEST_TAG"

    - name: Check if develop is ahead of main
      run: |
        # Check if develop has commits not on main
        COMMITS_AHEAD=$(git rev-list --count main..develop)

        if [ "$COMMITS_AHEAD" -eq 0 ]; then
          echo "ERROR: develop branch has no new commits compared to main"
          echo "There is nothing to release"
          exit 1
        fi

        echo "‚úì develop is $COMMITS_AHEAD commits ahead of main"

    - name: Get PRs merged to develop since last release
      id: get_prs
      uses: actions/github-script@v7
      with:
        script: |
          const tag = '${{ steps.get_tag.outputs.latest_tag }}';

          // Get the tag commit date
          const tagCommit = await github.rest.repos.getCommit({
            owner: context.repo.owner,
            repo: context.repo.repo,
            ref: tag
          });

          const tagDate = tagCommit.data.commit.committer.date;
          console.log(`Tag ${tag} was created at: ${tagDate}`);

          // Search for PRs merged to develop after the tag date
          const query = `repo:${context.repo.owner}/${context.repo.repo} is:pr is:merged base:develop merged:>${tagDate}`;
          console.log(`Search query: ${query}`);

          // Handle pagination to get all PRs
          let allPRs = [];
          let page = 1;
          let hasMore = true;

          while (hasMore) {
            const searchResult = await github.rest.search.issuesAndPullRequests({
              q: query,
              sort: 'updated',
              order: 'asc',
              per_page: 100,
              page: page
            });

            allPRs = allPRs.concat(searchResult.data.items);
            hasMore = searchResult.data.items.length === 100;
            page++;

            if (page > 10) {
              console.log('Warning: More than 1000 PRs found, stopping pagination');
              break;
            }
          }

          const prNumbers = allPRs.map(pr => pr.number);

          if (prNumbers.length === 0) {
            core.setFailed(`No merged PRs found on develop since ${tag}`);
            return [];
          }

          console.log(`Found ${prNumbers.length} merged PRs to develop: ${prNumbers.join(', ')}`);
          return prNumbers;

    - name: Fetch PR data and determine version bump
      id: analyze
      uses: actions/github-script@v7
      with:
        script: |
          const prNumbers = ${{ steps.get_prs.outputs.result }};
          const versionLabels = ['version:major', 'version:minor', 'version:patch', 'version:none'];
          const versionPriority = { 'major': 4, 'minor': 3, 'patch': 2, 'none': 1 };

          let highestBump = 'none';
          let highestPriority = 0;
          const prData = [];

          // Fetch PR details
          for (const prNumber of prNumbers) {
            try {
              const pr = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber
              });

              const labels = pr.data.labels.map(l => l.name);
              const versionLabel = labels.find(l => versionLabels.includes(l));

              if (!versionLabel) {
                console.log(`Warning: PR #${prNumber} has no version label, defaulting to 'none'`);
              }

              const bumpType = versionLabel ? versionLabel.split(':')[1] : 'none';
              const priority = versionPriority[bumpType] || 0;

              if (priority > highestPriority) {
                highestPriority = priority;
                highestBump = bumpType;
              }

              prData.push({
                number: prNumber,
                title: pr.data.title,
                author: pr.data.user.login,
                url: pr.data.html_url,
                bump_type: bumpType,
                labels: labels,
                body: pr.data.body || ''
              });
            } catch (error) {
              console.log(`Error fetching PR #${prNumber}: ${error.message}`);
            }
          }

          const shouldRelease = highestBump !== 'none';

          core.setOutput('should_release', shouldRelease);
          core.setOutput('bump_type', highestBump);
          core.setOutput('pr_data', JSON.stringify(prData));

          console.log(`Version bump: ${highestBump}`);
          console.log(`Should release: ${shouldRelease}`);
          console.log(`Total PRs analyzed: ${prData.length}`);

          if (!shouldRelease) {
            console.log('All PRs have version:none label - no release needed');
          }

  generate-changelog:
    needs: analyze-changes
    runs-on: ubuntu-latest
    outputs:
      new_version: ${{ steps.calc_version.outputs.new_version }}
      changelog_content: ${{ steps.generate.outputs.changelog_content }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        ref: develop
        fetch-depth: 0

    - name: Calculate new version
      id: calc_version
      run: |
        # Read current version from .bumpversion.cfg
        CURRENT_VERSION=$(grep '^current_version = ' .bumpversion.cfg | cut -d'=' -f2 | tr -d ' ')
        BUMP_TYPE="${{ needs.analyze-changes.outputs.bump_type }}"

        echo "Current version: $CURRENT_VERSION"
        echo "Bump type: $BUMP_TYPE"

        # Parse version
        IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"

        # Bump version
        case $BUMP_TYPE in
          major)
            MAJOR=$((MAJOR + 1))
            MINOR=0
            PATCH=0
            ;;
          minor)
            MINOR=$((MINOR + 1))
            PATCH=0
            ;;
          patch)
            PATCH=$((PATCH + 1))
            ;;
          none)
            echo "No version bump (type: none)"
            # Keep current version
            ;;
          *)
            echo "ERROR: Invalid bump type: $BUMP_TYPE"
            exit 1
            ;;
        esac

        NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}"
        echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT

        if [ "$BUMP_TYPE" = "none" ]; then
          echo "Version unchanged: $NEW_VERSION"
        else
          echo "New version will be: $NEW_VERSION"
        fi

    - name: Read pending changelog
      id: read_pending
      run: |
        if [ -f "changelogs/pending-changelog.md" ]; then
          # Read file and remove template placeholders
          PENDING_CONTENT=$(cat changelogs/pending-changelog.md | \
            grep -v '^\[' | \
            grep -v '<!--' | \
            grep -v '-->' | \
            sed '/^$/N;/^\n$/D' | \
            sed 's/^# Pending Release Notes//')

          # Check if there's actual content (not just headers)
          if echo "$PENDING_CONTENT" | grep -qv '^#'; then
            echo "Found pending changelog content"
            # Escape for JSON
            PENDING_CONTENT=$(echo "$PENDING_CONTENT" | jq -Rs .)
            echo "pending_content=$PENDING_CONTENT" >> $GITHUB_OUTPUT
          else
            echo "Pending changelog is empty (only template)"
            echo "pending_content=\"\"" >> $GITHUB_OUTPUT
          fi
        else
          echo "Warning: changelogs/pending-changelog.md not found"
          echo "pending_content=\"\"" >> $GITHUB_OUTPUT
        fi

    - name: Generate changelog
      id: generate
      uses: actions/github-script@v7
      env:
        PENDING_CONTENT: ${{ steps.read_pending.outputs.pending_content }}
        PR_DATA: ${{ needs.analyze-changes.outputs.pr_data }}
      with:
        script: |
          const version = '${{ steps.calc_version.outputs.new_version }}';
          const prData = JSON.parse(process.env.PR_DATA);
          const pendingContent = process.env.PENDING_CONTENT ? JSON.parse(process.env.PENDING_CONTENT) : '';
          const isDryRun = ${{ inputs.dry_run }};

          // Get current date
          const date = new Date().toISOString().split('T')[0];

          // Group PRs by bump type
          const groups = {
            breaking: [],  // version:major
            features: [],  // version:minor
            fixes: [],     // version:patch
            other: []      // version:none
          };

          for (const pr of prData) {
            switch (pr.bump_type) {
              case 'major':
                groups.breaking.push(pr);
                break;
              case 'minor':
                groups.features.push(pr);
                break;
              case 'patch':
                groups.fixes.push(pr);
                break;
              default:
                groups.other.push(pr);
            }
          }

          // Build changelog markdown
          let changelog = `# Release v${version} - ${date}\n\n`;

          // Add pending summary if available
          if (pendingContent && pendingContent.trim()) {
            changelog += `## Summary\n\n${pendingContent.trim()}\n\n---\n\n`;
          }

          // Add Breaking Changes section
          if (groups.breaking.length > 0) {
            changelog += `## Breaking Changes\n\n`;
            for (const pr of groups.breaking.sort((a, b) => a.number - b.number)) {
              changelog += `- **${pr.title}** ([#${pr.number}](${pr.url})) by @${pr.author}\n`;
            }
            changelog += '\n';
          }

          // Add Features section
          if (groups.features.length > 0) {
            changelog += `## Features\n\n`;
            for (const pr of groups.features.sort((a, b) => a.number - b.number)) {
              changelog += `- **${pr.title}** ([#${pr.number}](${pr.url})) by @${pr.author}\n`;
            }
            changelog += '\n';
          }

          // Add Bug Fixes section
          if (groups.fixes.length > 0) {
            changelog += `## Bug Fixes\n\n`;
            for (const pr of groups.fixes.sort((a, b) => a.number - b.number)) {
              changelog += `- **${pr.title}** ([#${pr.number}](${pr.url})) by @${pr.author}\n`;
            }
            changelog += '\n';
          }

          // Add Other Changes section
          if (groups.other.length > 0) {
            changelog += `## Other Changes\n\n`;
            for (const pr of groups.other.sort((a, b) => a.number - b.number)) {
              changelog += `- **${pr.title}** ([#${pr.number}](${pr.url})) by @${pr.author}\n`;
            }
            changelog += '\n';
          }

          // Add footer
          changelog += `---\n\n`;
          changelog += `**Installation:**\n\`\`\`bash\npip install neuracore==${version}\n\`\`\`\n\n`;
          changelog += `**Links:**\n`;
          changelog += `- PyPI: https://pypi.org/project/neuracore/${version}/\n`;
          changelog += `- GitHub Release: https://github.com/${context.repo.owner}/${context.repo.repo}/releases/tag/v${version}\n`;

          // Output changelog content
          core.setOutput('changelog_content', changelog);

          // Always write the changelog file (will be committed if not dry run)
          const fs = require('fs');
          const path = `changelogs/${version}-changelog.md`;

          // Ensure changelogs directory exists
          if (!fs.existsSync('changelogs')) {
            fs.mkdirSync('changelogs', { recursive: true });
          }

          fs.writeFileSync(path, changelog);
          console.log(`Changelog written to: ${path}`);

          // Print summary
          console.log(`\nChangelog Summary:`);
          console.log(`- Major Changes: ${groups.breaking.length}`);
          console.log(`- Minor Changes: ${groups.features.length}`);
          console.log(`- Patch Changes: ${groups.fixes.length}`);
          console.log(`- Misc/Chore Changes: ${groups.other.length}`);
          console.log(`- Total PRs: ${prData.length}`);

  version-bump:
    needs: [analyze-changes, generate-changelog]
    if: needs.analyze-changes.outputs.should_release == 'true' && inputs.dry_run == false
    runs-on: ubuntu-latest
    outputs:
      new_version: ${{ needs.generate-changelog.outputs.new_version }}
      commit_sha: ${{ steps.push.outputs.commit_sha }}

    steps:
    - name: Generate GitHub App Token
      id: generate-token
      uses: actions/create-github-app-token@v1
      with:
        app-id: ${{ vars.NC_VERSION_BUMPER_APP_ID }}
        private-key: ${{ secrets.NC_VERSION_BUMPER_PRIVATE_KEY }}

    - name: Checkout code
      uses: actions/checkout@v4
      with:
        ref: develop
        token: ${{ steps.generate-token.outputs.token }}
        fetch-depth: 0

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'

    - name: Install bump2version
      run: pip install bump2version

    - name: Bump version
      run: |
        BUMP_TYPE="${{ needs.analyze-changes.outputs.bump_type }}"

        echo "Bumping $BUMP_TYPE version"

        # Configure git
        git config user.email "github-actions[bot]@users.noreply.github.com"
        git config user.name "github-actions[bot]"

        # Use bump2version to bump the version (without committing)
        bump2version $BUMP_TYPE --allow-dirty --no-commit --no-tag

        NEW_VERSION=$(grep -m 1 '^current_version = ' .bumpversion.cfg | cut -d'=' -f2 | tr -d ' ')
        echo "Bumped to version: $NEW_VERSION"

    - name: Reset pending changelog
      run: |
        cat > changelogs/pending-changelog.md << 'EOF'
        # Pending Release Notes

        <!--
        This file contains a human-written summary for the next release.
        Append your changes below. This content will be included at the top of the release changelog.

        Example: "This release adds support for multi-GPU training and improves streaming performance by 40%."
        -->

        ## Summary

        <!-- Append your summary here -->
        EOF

        echo "Reset pending changelog to template"

    - name: Commit version bump and changelog
      run: |
        NEW_VERSION="${{ needs.generate-changelog.outputs.new_version }}"

        # Add all changed files
        git add .bumpversion.cfg neuracore/__init__.py changelogs/

        # Create commit
        git commit -m "Bump version to ${NEW_VERSION} [skip ci]"

        echo "Created version bump commit"

    - name: Push to develop
      id: push
      run: |
        git push origin develop

        COMMIT_SHA=$(git rev-parse HEAD)
        echo "commit_sha=$COMMIT_SHA" >> $GITHUB_OUTPUT

        echo "Pushed version bump commit to develop"
        echo "Commit SHA: $COMMIT_SHA"

  create-release-pr:
    needs: [analyze-changes, generate-changelog, version-bump]
    if: needs.analyze-changes.outputs.should_release == 'true' && inputs.dry_run == false
    runs-on: ubuntu-latest

    steps:
    - name: Generate GitHub App Token
      id: generate-token
      uses: actions/create-github-app-token@v1
      with:
        app-id: ${{ vars.NC_VERSION_BUMPER_APP_ID }}
        private-key: ${{ secrets.NC_VERSION_BUMPER_PRIVATE_KEY }}

    - name: Checkout code
      uses: actions/checkout@v4
      with:
        ref: develop
        token: ${{ steps.generate-token.outputs.token }}
        fetch-depth: 0

    - name: Pull latest develop
      run: git pull origin develop

    - name: Create Pull Request
      id: create_pr
      uses: actions/github-script@v7
      env:
        CHANGELOG_CONTENT: ${{ needs.generate-changelog.outputs.changelog_content }}
      with:
        github-token: ${{ steps.generate-token.outputs.token }}
        script: |
          const version = '${{ needs.version-bump.outputs.new_version }}';
          const changelogContent = process.env.CHANGELOG_CONTENT;
          const bumpType = '${{ needs.analyze-changes.outputs.bump_type }}';

          // Build PR body
          let prBody = `## Release v${version}\n\n`;
          prBody += `This PR merges the release preparation from \`develop\` into \`main\`.\n\n`;
          prBody += `**Version bump type:** \`${bumpType}\`\n\n`;
          prBody += `---\n\n`;
          prBody += `### Changelog Preview\n\n`;
          prBody += changelogContent;
          prBody += `\n---\n\n`;
          prBody += `**‚ö†Ô∏è Important:** This PR was automatically created by the \`prepare-release\` workflow.\n`;
          prBody += `When merged, the \`pr-publish-release\` workflow will automatically:\n`;
          prBody += `- Publish the package to PyPI\n`;
          prBody += `- Create a GitHub release with the above changelog\n`;
          prBody += `- Tag the release as \`v${version}\`\n`;

          const pr = await github.rest.pulls.create({
            owner: context.repo.owner,
            repo: context.repo.repo,
            title: `Release v${version}`,
            head: 'develop',
            base: 'main',
            body: prBody
          });

          console.log(`Created PR #${pr.data.number}: ${pr.data.html_url}`);

          // Add label to identify this as a release PR
          await github.rest.issues.addLabels({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: pr.data.number,
            labels: ['automated-release']
          });

          core.setOutput('pr_number', pr.data.number);
          core.setOutput('pr_url', pr.data.html_url);

    - name: Add PR summary
      uses: actions/github-script@v7
      with:
        script: |
          const prUrl = '${{ steps.create_pr.outputs.pr_url }}';
          const prNumber = '${{ steps.create_pr.outputs.pr_number }}';
          const version = '${{ needs.version-bump.outputs.new_version }}';

          const fs = require('fs');
          let summary = `# ‚úÖ Release PR Created\n\n`;
          summary += `**Version:** \`${version}\`\n\n`;
          summary += `**Pull Request:** [#${prNumber}](${prUrl})\n\n`;
          summary += `---\n\n`;
          summary += `## Next Steps\n\n`;
          summary += `1. Review the release PR: ${prUrl}\n`;
          summary += `2. Merge the PR to trigger the \`publish-release\` workflow\n`;
          summary += `3. The package will be automatically published to PyPI\n`;
          summary += `4. A GitHub release will be created automatically\n`;

          fs.appendFileSync(process.env.GITHUB_STEP_SUMMARY, summary);

  dry-run-summary:
    needs: [analyze-changes, generate-changelog]
    if: inputs.dry_run == true
    runs-on: ubuntu-latest

    steps:
    - name: Generate dry run summary
      uses: actions/github-script@v7
      env:
        CHANGELOG_CONTENT: ${{ needs.generate-changelog.outputs.changelog_content }}
      with:
        script: |
          const shouldRelease = '${{ needs.analyze-changes.outputs.should_release }}' === 'true';
          const bumpType = '${{ needs.analyze-changes.outputs.bump_type }}';
          const newVersion = '${{ needs.generate-changelog.outputs.new_version }}';
          const changelogContent = process.env.CHANGELOG_CONTENT || '';

          const fs = require('fs');
          let summary = '';

          if (!shouldRelease) {
            summary += '# ‚ö†Ô∏è No Release Needed\n\n';
            summary += 'All PRs merged to develop since the last release have `version:none` label.\n\n';
            summary += 'No version bump or release will be created.\n\n';
            summary += '---\n\n';
            summary += '## Changelog Preview\n\n';
            summary += changelogContent;
          } else {
            summary += '# üß™ Dry Run Complete\n\n';
            summary += '**‚ö†Ô∏è This was a DRY RUN** - no changes were made\n\n';
            summary += '## What Would Happen\n\n';
            summary += `- **Version Bump:** \`${bumpType}\` ‚Üí \`${newVersion}\`\n`;
            summary += `- ‚úÖ Version updated in \`.bumpversion.cfg\` and \`neuracore/__init__.py\`\n`;
            summary += `- ‚úÖ Changelog created at \`changelogs/${newVersion}-changelog.md\`\n`;
            summary += `- ‚úÖ Pending changelog reset to template\n`;
            summary += `- ‚úÖ Changes committed to \`develop\` branch\n`;
            summary += `- ‚úÖ Pull Request created: \`develop\` ‚Üí \`main\`\n`;
            summary += `- ‚úÖ On PR merge: Package published to PyPI, GitHub release created\n\n`;
            summary += `---\n\n`;
            summary += `## Changelog Preview\n\n`;
            summary += changelogContent;
            summary += `\n---\n\n`;
            summary += `**To perform the actual release:** Run this workflow again **without** the \`dry_run\` option checked.\n`;
          }

          fs.appendFileSync(process.env.GITHUB_STEP_SUMMARY, summary);

  final-check:
    needs: [analyze-changes, generate-changelog]
    if: always() && needs.analyze-changes.outputs.should_release != 'true' && inputs.dry_run == false
    runs-on: ubuntu-latest

    steps:
    - name: Fail if no release needed
      run: |
        echo "ERROR: Cannot create a release - all PRs have version:none label"
        echo "Run with dry_run: true to see what would be released"
        exit 1
