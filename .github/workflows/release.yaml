name: Release
run-name: ${{ inputs.dry_run && 'Release (Dry Run)' || 'Release' }}

on:
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Dry run mode (only show what would happen, no commits/pushes/publishes)'
        required: false
        type: boolean
        default: false

jobs:
  analyze-changes:
    runs-on: ubuntu-latest
    outputs:
      should_release: ${{ steps.analyze.outputs.should_release }}
      bump_type: ${{ steps.analyze.outputs.bump_type }}
      pr_data: ${{ steps.analyze.outputs.pr_data }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Need full history for tag comparison

    - name: Get latest release tag
      id: get_tag
      run: |
        LATEST_TAG=$(git describe --tags --abbrev=0 --match "v*" 2>/dev/null || echo "")
        if [ -z "$LATEST_TAG" ]; then
          echo "ERROR: No previous release tag found"
          exit 1
        fi
        echo "latest_tag=$LATEST_TAG" >> $GITHUB_OUTPUT
        echo "Found latest release tag: $LATEST_TAG"

    - name: Get PRs merged since last release
      id: get_prs
      uses: actions/github-script@v7
      with:
        script: |
          const tag = '${{ steps.get_tag.outputs.latest_tag }}';

          // Use compare API to get the date of the tag commit
          const comparison = await github.rest.repos.compareCommitsWithBasehead({
            owner: context.repo.owner,
            repo: context.repo.repo,
            basehead: `${tag}...HEAD`
          });

          if (comparison.data.commits.length === 0) {
            console.log('No commits since last release');
            return [];
          }

          // Get the base commit (the tag's commit) date
          const baseCommit = await github.rest.repos.getCommit({
            owner: context.repo.owner,
            repo: context.repo.repo,
            ref: tag
          });

          const tagDate = baseCommit.data.commit.committer.date;
          console.log(`Tag ${tag} was created at: ${tagDate}`);

          // Search for PRs merged to main after the tag date
          const query = `repo:${context.repo.owner}/${context.repo.repo} is:pr is:merged base:main merged:>${tagDate}`;
          console.log(`Search query: ${query}`);

          // Handle pagination to get all PRs (not just first 100)
          let allPRs = [];
          let page = 1;
          let hasMore = true;

          while (hasMore) {
            const searchResult = await github.rest.search.issuesAndPullRequests({
              q: query,
              sort: 'updated',
              order: 'asc',
              per_page: 100,
              page: page
            });

            allPRs = allPRs.concat(searchResult.data.items);
            hasMore = searchResult.data.items.length === 100;
            page++;

            if (page > 10) {
              console.log('Warning: More than 1000 PRs found, stopping pagination');
              break;
            }
          }

          const prNumbers = allPRs.map(pr => pr.number);

          if (prNumbers.length === 0) {
            core.setFailed(`No merged PRs found since ${tag}`);
            return [];
          }

          console.log(`Found ${prNumbers.length} merged PRs: ${prNumbers.join(', ')}`);
          return prNumbers;

    - name: Fetch PR data and determine version bump
      id: analyze
      uses: actions/github-script@v7
      with:
        script: |
          const prNumbers = ${{ steps.get_prs.outputs.result }};
          const versionLabels = ['version:major', 'version:minor', 'version:patch', 'version:none'];
          const versionPriority = { 'major': 4, 'minor': 3, 'patch': 2, 'none': 1 };

          let highestBump = 'none';
          let highestPriority = 0;
          const prData = [];

          // Fetch PR details
          for (const prNumber of prNumbers) {
            try {
              const pr = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber
              });

              const labels = pr.data.labels.map(l => l.name);
              const versionLabel = labels.find(l => versionLabels.includes(l));

              if (!versionLabel) {
                console.log(`Warning: PR #${prNumber} has no version label, defaulting to 'none'`);
              }

              const bumpType = versionLabel ? versionLabel.split(':')[1] : 'none';
              const priority = versionPriority[bumpType] || 0;

              if (priority > highestPriority) {
                highestPriority = priority;
                highestBump = bumpType;
              }

              prData.push({
                number: prNumber,
                title: pr.data.title,
                author: pr.data.user.login,
                url: pr.data.html_url,
                bump_type: bumpType,
                labels: labels,
                body: pr.data.body || ''
              });
            } catch (error) {
              console.log(`Error fetching PR #${prNumber}: ${error.message}`);
            }
          }

          const shouldRelease = highestBump !== 'none';

          core.setOutput('should_release', shouldRelease);
          core.setOutput('bump_type', highestBump);
          core.setOutput('pr_data', JSON.stringify(prData));

          console.log(`Version bump: ${highestBump}`);
          console.log(`Should release: ${shouldRelease}`);
          console.log(`Total PRs analyzed: ${prData.length}`);

          if (!shouldRelease) {
            console.log('All PRs have version:none label - no release needed');
          }

  generate-changelog:
    needs: analyze-changes
    runs-on: ubuntu-latest
    outputs:
      new_version: ${{ steps.calc_version.outputs.new_version }}
      changelog_content: ${{ steps.generate.outputs.changelog_content }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Calculate new version
      id: calc_version
      run: |
        # Read current version from .bumpversion.cfg
        CURRENT_VERSION=$(grep '^current_version = ' .bumpversion.cfg | cut -d'=' -f2 | tr -d ' ')
        BUMP_TYPE="${{ needs.analyze-changes.outputs.bump_type }}"

        echo "Current version: $CURRENT_VERSION"
        echo "Bump type: $BUMP_TYPE"

        # Parse version
        IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"

        # Bump version
        case $BUMP_TYPE in
          major)
            MAJOR=$((MAJOR + 1))
            MINOR=0
            PATCH=0
            ;;
          minor)
            MINOR=$((MINOR + 1))
            PATCH=0
            ;;
          patch)
            PATCH=$((PATCH + 1))
            ;;
          none)
            echo "No version bump (type: none)"
            # Keep current version
            ;;
          *)
            echo "ERROR: Invalid bump type: $BUMP_TYPE"
            exit 1
            ;;
        esac

        NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}"
        echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT

        if [ "$BUMP_TYPE" = "none" ]; then
          echo "Version unchanged: $NEW_VERSION"
        else
          echo "New version will be: $NEW_VERSION"
        fi

    - name: Read pending changelog
      id: read_pending
      run: |
        if [ -f "changelogs/pending-changelog.md" ]; then
          # Read file and remove template placeholders
          PENDING_CONTENT=$(cat changelogs/pending-changelog.md | \
            grep -v '^\[' | \
            grep -v '<!--' | \
            grep -v '-->' | \
            sed '/^$/N;/^\n$/D' | \
            sed 's/^# Pending Release Notes//')

          # Check if there's actual content (not just headers)
          if echo "$PENDING_CONTENT" | grep -qv '^#'; then
            echo "Found pending changelog content"
            # Escape for JSON
            PENDING_CONTENT=$(echo "$PENDING_CONTENT" | jq -Rs .)
            echo "pending_content=$PENDING_CONTENT" >> $GITHUB_OUTPUT
          else
            echo "Pending changelog is empty (only template)"
            echo "pending_content=\"\"" >> $GITHUB_OUTPUT
          fi
        else
          echo "Warning: changelogs/pending-changelog.md not found"
          echo "pending_content=\"\"" >> $GITHUB_OUTPUT
        fi

    - name: Generate changelog
      id: generate
      uses: actions/github-script@v7
      env:
        PENDING_CONTENT: ${{ steps.read_pending.outputs.pending_content }}
        PR_DATA: ${{ needs.analyze-changes.outputs.pr_data }}
      with:
        script: |
          const version = '${{ steps.calc_version.outputs.new_version }}';
          const prData = JSON.parse(process.env.PR_DATA);
          const pendingContent = process.env.PENDING_CONTENT ? JSON.parse(process.env.PENDING_CONTENT) : '';
          const isDryRun = ${{ inputs.dry_run }};

          // Get current date
          const date = new Date().toISOString().split('T')[0];

          // Group PRs by bump type
          const groups = {
            breaking: [],  // version:major
            features: [],  // version:minor
            fixes: [],     // version:patch
            other: []      // version:none
          };

          for (const pr of prData) {
            switch (pr.bump_type) {
              case 'major':
                groups.breaking.push(pr);
                break;
              case 'minor':
                groups.features.push(pr);
                break;
              case 'patch':
                groups.fixes.push(pr);
                break;
              default:
                groups.other.push(pr);
            }
          }

          // Build changelog markdown
          let changelog = `# Release v${version} - ${date}\n\n`;

          // Add pending summary if available
          if (pendingContent && pendingContent.trim()) {
            changelog += `## Summary\n\n${pendingContent.trim()}\n\n---\n\n`;
          }

          // Add Breaking Changes section
          if (groups.breaking.length > 0) {
            changelog += `## Breaking Changes\n\n`;
            for (const pr of groups.breaking.sort((a, b) => a.number - b.number)) {
              changelog += `- **${pr.title}** ([#${pr.number}](${pr.url})) by @${pr.author}\n`;
            }
            changelog += '\n';
          }

          // Add Features section
          if (groups.features.length > 0) {
            changelog += `## Features\n\n`;
            for (const pr of groups.features.sort((a, b) => a.number - b.number)) {
              changelog += `- **${pr.title}** ([#${pr.number}](${pr.url})) by @${pr.author}\n`;
            }
            changelog += '\n';
          }

          // Add Bug Fixes section
          if (groups.fixes.length > 0) {
            changelog += `## Bug Fixes\n\n`;
            for (const pr of groups.fixes.sort((a, b) => a.number - b.number)) {
              changelog += `- **${pr.title}** ([#${pr.number}](${pr.url})) by @${pr.author}\n`;
            }
            changelog += '\n';
          }

          // Add Other Changes section
          if (groups.other.length > 0) {
            changelog += `## Other Changes\n\n`;
            for (const pr of groups.other.sort((a, b) => a.number - b.number)) {
              changelog += `- **${pr.title}** ([#${pr.number}](${pr.url})) by @${pr.author}\n`;
            }
            changelog += '\n';
          }

          // Add footer
          changelog += `---\n\n`;
          changelog += `**Installation:**\n\`\`\`bash\npip install neuracore==${version}\n\`\`\`\n\n`;
          changelog += `**Links:**\n`;
          changelog += `- PyPI: https://pypi.org/project/neuracore/${version}/\n`;
          changelog += `- GitHub Release: https://github.com/Neuraco/neuracore/releases/tag/v${version}\n`;

          // Output changelog content
          core.setOutput('changelog_content', changelog);

          // Always write the changelog file (version-bump will commit it if not dry run)
          const fs = require('fs');
          const path = `changelogs/${version}-changelog.md`;

          // Ensure changelogs directory exists
          if (!fs.existsSync('changelogs')) {
            fs.mkdirSync('changelogs', { recursive: true });
          }

          fs.writeFileSync(path, changelog);
          console.log(`Changelog written to: ${path}`);

          // Print summary
          console.log(`\nChangelog Summary:`);
          console.log(`- Major Changes: ${groups.breaking.length}`);
          console.log(`- Minor Changes: ${groups.features.length}`);
          console.log(`- Patch Changes: ${groups.fixes.length}`);
          console.log(`- Misc/Chore Changes: ${groups.other.length}`);
          console.log(`- Total PRs: ${prData.length}`);

  version-bump:
    needs: [analyze-changes, generate-changelog]
    if: needs.analyze-changes.outputs.should_release == 'true' && inputs.dry_run == false
    runs-on: ubuntu-latest
    outputs:
      new_version: ${{ needs.generate-changelog.outputs.new_version }}

    steps:
    - name: Generate GitHub App Token
      id: generate-token
      uses: actions/create-github-app-token@v1
      with:
        app-id: ${{ vars.NC_VERSION_BUMPER_APP_ID }}
        private-key: ${{ secrets.NC_VERSION_BUMPER_PRIVATE_KEY }}

    - name: Checkout code
      uses: actions/checkout@v4
      with:
        token: ${{ steps.generate-token.outputs.token }}
        fetch-depth: 0

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'

    - name: Install bump2version
      run: pip install bump2version

    - name: Bump version
      run: |
        BUMP_TYPE="${{ needs.analyze-changes.outputs.bump_type }}"

        echo "Bumping $BUMP_TYPE version"

        # Configure git
        git config user.email "github-actions[bot]@users.noreply.github.com"
        git config user.name "github-actions[bot]"

        # Use bump2version to bump the version
        bump2version $BUMP_TYPE --allow-dirty

        NEW_VERSION=$(grep -m 1 '^current_version = ' .bumpversion.cfg | cut -d'=' -f2 | tr -d ' ')
        echo "Bumped to version: $NEW_VERSION"

    - name: Reset pending changelog
      run: |
        cat > changelogs/pending-changelog.md << 'EOF'
        # Pending Release Notes

        <!--
        This file contains a human-written summary for the next release.
        Append your changes below. This content will be included at the top of the release changelog.

        Example: "This release adds support for multi-GPU training and improves streaming performance by 40%."
        -->

        ## Summary

        <!-- Append your summary here -->
        EOF

        echo "Reset pending changelog to template"

    - name: Commit changelog and pending reset
      run: |
        # Add changelog files to the version bump commit
        git add changelogs/
        git commit --amend --no-edit

        echo "Added changelog files to version bump commit"

    - name: Push changes
      run: |
        git push origin main --tags
        echo "Pushed version bump commit and tags to main"

  publish-python:
    needs: version-bump
    if: inputs.dry_run == false
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        ref: main
        fetch-depth: 0

    - name: Pull latest changes
      run: git pull --tags

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'

    - name: Install build tools
      run: |
        pip install --upgrade pip
        pip install build twine

    - name: Build Python package
      run: python -m build

    - name: Publish to PyPI
      env:
        TWINE_USERNAME: ${{ secrets.PYPI_USERNAME }}
        TWINE_PASSWORD: ${{ secrets.PYPI_PASSWORD }}
      run: twine upload --skip-existing dist/*

  create-release:
    needs: [version-bump, publish-python, generate-changelog]
    if: inputs.dry_run == false
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        ref: main
        fetch-depth: 0

    - name: Pull latest changes
      run: git pull --tags

    - name: Create GitHub Release
      uses: actions/github-script@v7
      env:
        CHANGELOG_BODY: ${{ needs.generate-changelog.outputs.changelog_content }}
      with:
        script: |
          const version = '${{ needs.version-bump.outputs.new_version }}';
          const changelogBody = process.env.CHANGELOG_BODY;

          await github.rest.repos.createRelease({
            owner: context.repo.owner,
            repo: context.repo.repo,
            tag_name: `v${version}`,
            name: `Release v${version}`,
            body: changelogBody,
            draft: false,
            prerelease: false
          });

          console.log(`Created GitHub Release for v${version}`);

  final-summary:
    needs: [analyze-changes, generate-changelog, version-bump, publish-python, create-release]
    if: always()
    runs-on: ubuntu-latest

    steps:
    - name: Generate final summary
      uses: actions/github-script@v7
      env:
        CHANGELOG_CONTENT: ${{ needs.generate-changelog.outputs.changelog_content }}
      with:
        script: |
          const isDryRun = ${{ inputs.dry_run }};
          const shouldRelease = '${{ needs.analyze-changes.outputs.should_release }}' === 'true';
          const bumpType = '${{ needs.analyze-changes.outputs.bump_type }}';
          const newVersion = '${{ needs.generate-changelog.outputs.new_version }}';
          const changelogContent = process.env.CHANGELOG_CONTENT || '';

          const fs = require('fs');
          let summary = '';

          // Check if trying to do a real release with only version:none PRs
          if (!isDryRun && !shouldRelease) {
            summary += '# ‚ùå Release Failed\n\n';
            summary += '**Cannot create a release** - all PRs since the last release have `version:none` label.\n\n';
            summary += 'See the "Release Analysis" section for details on the PRs that were analyzed.\n\n';
            summary += '---\n\n';
            summary += '**To create a release:** Ensure at least one merged PR has a `version:major`, `version:minor`, or `version:patch` label.\n';
            fs.appendFileSync(process.env.GITHUB_STEP_SUMMARY, summary);
            core.setFailed('Cannot create release - all PRs have version:none label');
            return;
          }

          if (isDryRun) {
            summary += '# üß™ Dry Run Complete\n\n';
            summary += '**‚ö†Ô∏è This was a DRY RUN** - no changes were committed or published\n\n';
          } else {
            summary += '# ‚úÖ Release Complete\n\n';
          }

          if (shouldRelease) {
            summary += '## Release Information\n\n';
            summary += `- **Version Bump:** \`${bumpType}\`\n`;
            summary += `- **New Version:** \`${newVersion}\`\n\n`;

            if (isDryRun) {
              summary += '## What Would Happen\n\n';
              summary += '- ‚úÖ Version bumped in `.bumpversion.cfg` and `neuracore/__init__.py`\n';
              summary += `- ‚úÖ Changelog created at \`changelogs/${newVersion}-changelog.md\`\n`;
              summary += '- ‚úÖ Pending changelog reset to template\n';
              summary += `- ‚úÖ Changes committed and pushed with tag \`v${newVersion}\`\n`;
              summary += '- ‚úÖ Package published to PyPI\n';
              summary += '- ‚úÖ GitHub Release created\n\n';
              summary += '---\n\n';
              summary += '**To perform the actual release:** Run this workflow again **without** the `dry_run` option checked.\n\n';
            } else {
              summary += '## Actions Completed\n\n';
              summary += '- ‚úÖ Version bumped and committed\n';
              summary += '- ‚úÖ Package published to PyPI\n';
              summary += '- ‚úÖ GitHub Release created\n\n';
              summary += '### Links\n\n';
              summary += `- üì¶ [PyPI Package](https://pypi.org/project/neuracore/${newVersion}/)\n`;
              summary += `- üè∑Ô∏è [GitHub Release](https://github.com/${context.repo.owner}/${context.repo.repo}/releases/tag/v${newVersion})\n`;
              summary += `- üìù [Changelog](https://github.com/${context.repo.owner}/${context.repo.repo}/blob/main/changelogs/${newVersion}-changelog.md)\n\n`;
              summary += '### Installation\n\n';
              summary += '```bash\n';
              summary += `pip install neuracore==${newVersion}\n`;
              summary += '```\n\n';
            }

            summary += '---\n\n';
            summary += '## Generated Changelog\n\n';
            summary += changelogContent;
          } else {
            // This is dry run with version:none - show what we found
            summary += '## No Release Would Be Created\n\n';
            summary += `All PRs since the last release have \`version:none\` label.\n\n`;
            summary += 'See the "Release Analysis" section for details on the PRs that were analyzed.\n\n';
            summary += '---\n\n';
            summary += '## Generated Changelog\n\n';
            summary += changelogContent;
          }

          fs.appendFileSync(process.env.GITHUB_STEP_SUMMARY, summary);
