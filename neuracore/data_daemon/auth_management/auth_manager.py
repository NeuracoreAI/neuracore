"""Authentication management."""

import logging
import os
from pathlib import Path

import aiofiles
import aiohttp
from pydantic import BaseModel, ValidationError

from neuracore.data_daemon.config_manager.daemon_config import DaemonConfig
from neuracore.data_daemon.const import (
    API_URL,
    CONFIG_DIR,
    CONFIG_ENCODING,
    CONFIG_FILE,
)

logger = logging.getLogger(__name__)


class AuthConfig(BaseModel):
    """Authentication configuration model.

    This uses the config file generated by the python frontend to
    share authentication state.

    Attributes:
        api_key: Neuracore API key for authentication.
        current_org_id: Organization ID for the authenticated user.
    """

    api_key: str | None = None
    current_org_id: str | None = None


class AuthenticationError(Exception):
    """Raised when authentication fails."""

    pass


class ConfigError(Exception):
    """Raised when configuration operations fail."""

    pass


class AuthManager:
    """Manages authentication state for the data daemon."""

    def __init__(self, daemon_config: DaemonConfig, config_path: Path | None = None):
        """Initialize the AuthManager.

        Args:
            daemon_config: DaemonConfig instance to store auth values.
            config_path: Path to the auth configuration file.
        """
        if config_path is None:
            config_path = CONFIG_DIR / CONFIG_FILE

        self._config_path = config_path
        self._access_token: str | None = None
        self._config: DaemonConfig = daemon_config

    async def _load_config(self) -> None:
        """Load authentication configuration from disk and set on DaemonConfig.

        Raises:
            ConfigError: If there is an error loading the config.
        """
        if not self._config_path.exists():
            logger.error(f"Config file {self._config_path} does not exist")
            return

        try:
            async with aiofiles.open(
                self._config_path, "r", encoding=CONFIG_ENCODING
            ) as f:
                content = await f.read()
                config_data = AuthConfig.model_validate_json(content)
            # Set auth values on DaemonConfig
            if config_data.api_key:
                self._config.api_key = config_data.api_key
            if config_data.current_org_id:
                self._config.current_org_id = config_data.current_org_id

        except ValidationError as e:
            raise ConfigError(f"Error loading config: invalid structure - {e}")
        except PermissionError as e:
            raise ConfigError(f"Error loading config: insufficient permissions - {e}")
        except UnicodeDecodeError as e:
            raise ConfigError(f"Error loading config: invalid encoding - {e}")
        except OSError as e:
            raise ConfigError(f"Error loading config: cannot open file - {e}")

    async def load_config(self) -> DaemonConfig:
        """Get the current configuration, loading from disk if necessary.

        Returns:
            The current DaemonConfig.

        Raises:
            ConfigError: If there is an error loading the config.
        """
        await self._load_config()
        return self._config

    async def get_api_key(self) -> str:
        """Get the API key from environment or config.

        Returns:
            The API key.

        Raises:
            AuthenticationError: If no API key is available.
        """
        await self._load_config()

        api_key = os.environ.get("NEURACORE_API_KEY") or self._config.api_key

        if not api_key:
            raise AuthenticationError("No API key found.")

        return api_key

    async def get_org_id(self) -> str:
        """Get the organization ID.

        Returns:
            The organization ID.

        Raises:
            AuthenticationError: If no org_id is configured.
        """
        await self._load_config()

        if not self._config.current_org_id:
            raise AuthenticationError("No organization ID configured.")

        return self._config.current_org_id

    async def get_access_token(
        self, session: aiohttp.ClientSession | None = None
    ) -> str:
        """Get a valid access token, obtaining a new one if necessary.

        Args:
            session: Optional aiohttp session. If not provided, creates a new one.

        Returns:
            A valid access token.

        Raises:
            AuthenticationError: If token retrieval fails.
        """
        if self._access_token is not None:
            return self._access_token

        api_key = await self.get_api_key()

        async def _fetch_token(client: aiohttp.ClientSession) -> str:
            try:
                async with client.post(
                    f"{API_URL}/auth/verify-api-key",
                    json={"api_key": api_key},
                    timeout=aiohttp.ClientTimeout(total=10),
                ) as response:
                    if response.status != 200:
                        raise AuthenticationError(
                            f"Failed to verify API key: {response.status}"
                        )

                    token_data = await response.json()
                    access_token = token_data.get("access_token")

                    if not access_token:
                        raise AuthenticationError("No access token in response")

                    return access_token

            except aiohttp.ClientConnectionError as e:
                raise AuthenticationError(
                    f"Failed to connect to Neuracore server: {e}"
                ) from e
            except TimeoutError as e:
                raise AuthenticationError(f"Request timed out: {e}") from e
            except aiohttp.ClientError as e:
                raise AuthenticationError(f"Failed to get access token: {e}") from e

        if session is not None:
            self._access_token = await _fetch_token(session)
        else:
            async with aiohttp.ClientSession() as client:
                self._access_token = await _fetch_token(client)

        return self._access_token

    async def get_headers(
        self, session: aiohttp.ClientSession | None = None
    ) -> dict[str, str]:
        """Get HTTP headers for authenticated API requests.

        Args:
            session: Optional aiohttp session for token retrieval.

        Returns:
            Dict containing the Authorization header with bearer token.

        Raises:
            AuthenticationError: If unable to obtain a valid access token.
        """
        access_token = await self.get_access_token(session)
        return {"Authorization": f"Bearer {access_token}"}

    def invalidate_token(self) -> None:
        """Invalidate the current access token."""
        self._access_token = None


_auth: AuthManager | None = None


def initialize_auth(
    daemon_config: DaemonConfig | None = None, config_path: Path | None = None
) -> None:
    """Initialize the global AuthManager instance.

    This is called automatically by get_auth() if not already initialized.
    Can also be called explicitly during daemon startup.

    Args:
        daemon_config: Optional daemon configuration. If not provided,
                      a default DaemonConfig is created.
        config_path: Optional path to config.json file.
    """
    global _auth

    if daemon_config is None:
        daemon_config = DaemonConfig()

    _auth = AuthManager(daemon_config=daemon_config, config_path=config_path)
    logger.info("AuthManager initialized")


def get_auth() -> AuthManager:
    """Get the global AuthManager singleton instance.

    Returns:
        The global AuthManager instance used throughout the application.

    Raises:
        RuntimeError: If auth has not been initialized.
    """
    if _auth is None:
        raise RuntimeError("AuthManager not initialized. Call initialize_auth() first.")
    return _auth
